<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calibrated Orientation Visualizer</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; margin: 0; padding: 10px; background-color: #f0f0f0; color: #333; overscroll-behavior-y: contain; font-size: 15px; }
        .container { display: flex; flex-direction: column; gap: 15px; }
        .permission-section, .calibration-notice, .live-raw-value-display, .controls, .chart-container, .logs {
            text-align: center; padding: 15px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 15px;
        }
        .live-raw-value-display { text-align: left; }
        .live-raw-value-display h3 { margin-top: 0; font-size: 1.2em; color: #007bff; }
        .live-raw-value-display p { font-size: 1.5em; font-weight: bold; color: #333; margin: 5px 0; font-family: "SF Mono", Menlo, Monaco, monospace; }
        .live-raw-value-display strong { color: #555; }

        .controls label { margin-bottom: 5px; font-weight: bold; display: block; }
        .controls select { padding: 10px; border-radius: 5px; border: 1px solid #ccc; font-size: 1em; box-sizing: border-box; width: 100%; max-width: 300px; margin: 0 auto; }
        
        .chart-container h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.2em; }
        .permission-section button { padding: 12px 20px; border-radius: 5px; border: none; font-size: 1em; background-color: #007bff; color: white; cursor: pointer; }
        .permission-section button:hover { background-color: #0056b3; }

        .logs h3 { margin-top: 0; }
        .log-area { max-height: 150px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; font-size: 0.8em; background-color: #f9f9f9; white-space: pre-wrap; text-align: left; }
        .log-entry.error { color: red; font-weight: bold; }
        .log-entry.warn { color: orange; }
        .log-entry.debug { color: blue; }
        .log-entry.info { color: green; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Calibrated Orientation Visualizer</h1>

        <div id="permissionSection" class="permission-section">
            <p>This app requires access to your device's orientation sensors.</p>
            <button id="requestPermissionButton">Grant Orientation Sensor Access</button>
        </div>

        <div id="calibrationNotice" class="calibration-notice hidden">
            <p id="calibrationText">Initializing calibration...</p>
        </div>

        <div id="liveRawValueDisplay" class="live-raw-value-display hidden">
            <h3>Live Raw Value (<span id="liveRawValueLabel">Alpha</span>):</h3>
            <p><span id="currentRawValue">---</span></p>
        </div>

        <div id="mainContent" class="hidden">
            <div class="controls">
                <label for="sensorSelect">Select Data for Chart (Zero-Adjusted):</label>
                <select id="sensorSelect">
                    <option value="alpha">Alpha (Compass/Z-axis)</option>
                    <option value="beta">Beta (X-axis)</option>
                    <option value="gamma">Gamma (Y-axis)</option>
                    <option value="webkitCompassHeading">WebKit Compass Heading</option>
                </select>
            </div>

            <div class="chart-container">
                <h3 id="chartTitle">Zero-Adjusted Alpha</h3>
                <canvas id="orientationChart"></canvas>
            </div>
        </div>

        <div class="logs">
            <h3>Event & Error Logs</h3>
            <div id="logArea" class="log-area"></div>
        </div>
    </div>

    <script>
        const MAX_CHART_POINTS = 100; // Show more points for time series
        const CALIBRATION_DURATION_S = 20;

        // DOM Elements
        const logArea = document.getElementById('logArea');
        const permissionSection = document.getElementById('permissionSection');
        const requestPermissionButton = document.getElementById('requestPermissionButton');
        const calibrationNotice = document.getElementById('calibrationNotice');
        const calibrationText = document.getElementById('calibrationText');
        const liveRawValueDisplayDiv = document.getElementById('liveRawValueDisplay');
        const liveRawValueLabelEl = document.getElementById('liveRawValueLabel');
        const currentRawValueEl = document.getElementById('currentRawValue');
        const mainContent = document.getElementById('mainContent');
        const sensorSelect = document.getElementById('sensorSelect');
        const chartTitleEl = document.getElementById('chartTitle');
        
        let orientationChart;
        let currentChartKey = 'alpha'; // Matches initial select option value

        // Calibration and Data
        let calibrationState = 'pending'; // pending, collecting, complete
        let calibrationStartTime;
        let tempCalibrationData = { alpha: [], beta: [], gamma: [], webkitCompassHeading: [] };
        let sensorZeroOffsets = { alpha: 0, beta: 0, gamma: 0, webkitCompassHeading: 0 };
        
        // Charting Data: Stores the *adjusted* values for the chart
        let chartData = {
            alpha: { values: [], labels: [] },
            beta: { values: [], labels: [] },
            gamma: { values: [], labels: [] },
            webkitCompassHeading: { values: [], labels: [] }
        };

        // Throttling and Sensor State
        let orientationSensorActive = false;
        let orientationEventListenerType = null;
        let lastSensorEventData = null; // Store the latest raw event data
        
        const RAW_DISPLAY_UPDATE_INTERVAL_MS = 200; // ~5Hz for live raw value
        let lastRawDisplayUpdateTime = 0;
        let rawDisplayUpdateLoopId = null;

        const CHART_UPDATE_INTERVAL_MS = 500; // ~2Hz for chart
        let lastChartUpdateTime = 0;
        let chartUpdateLoopId = null;


        function logMessage(message, type = 'info') {
            const entry = document.createElement('div');
            entry.classList.add('log-entry', type);
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function formatSensorValue(value, precision = 2) { // Less precision for display often fine
            if (value === null || typeof value === 'undefined') return '---';
            if (typeof value === 'boolean') return value.toString();
            if (typeof value === 'number') {
                if (isNaN(value) || !isFinite(value)) return value.toString();
                return value.toFixed(precision);
            }
            return String(value);
        }

        function createChart() {
            const ctx = document.getElementById('orientationChart').getContext('2d');
            return new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [{ label: 'Zero-Adjusted Value', data: [], borderColor: 'rgb(0, 123, 255)', tension: 0.1, fill: false }] },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    scales: { x: { title: { display: true, text: 'Time' } }, y: { title: { display: true, text: 'Adjusted Value' } } },
                    animation: { duration: 0 }
                }
            });
        }

        function handleCalibrationLogic(eventData) {
            if (calibrationState === 'pending' && orientationSensorActive) {
                calibrationState = 'collecting';
                calibrationStartTime = Date.now();
                calibrationNotice.classList.remove('hidden');
                liveRawValueDisplayDiv.classList.remove('hidden'); // Show raw display now
                logMessage(`Calibration started. Collecting data for ${CALIBRATION_DURATION_S} seconds. Keep device relatively still.`, 'info');
            }

            if (calibrationState === 'collecting') {
                const elapsedS = (Date.now() - calibrationStartTime) / 1000;
                calibrationText.textContent = `Calibrating... Keep device still. ${Math.max(0, CALIBRATION_DURATION_S - elapsedS).toFixed(0)}s remaining. Samples: ${tempCalibrationData.alpha.length}`;

                if (eventData.alpha !== null && typeof eventData.alpha !== 'undefined') tempCalibrationData.alpha.push(eventData.alpha);
                if (eventData.beta !== null && typeof eventData.beta !== 'undefined') tempCalibrationData.beta.push(eventData.beta);
                if (eventData.gamma !== null && typeof eventData.gamma !== 'undefined') tempCalibrationData.gamma.push(eventData.gamma);
                if (eventData.webkitCompassHeading !== null && typeof eventData.webkitCompassHeading !== 'undefined') tempCalibrationData.webkitCompassHeading.push(eventData.webkitCompassHeading);

                if (elapsedS >= CALIBRATION_DURATION_S) {
                    calibrationState = 'complete';
                    ['alpha', 'beta', 'gamma', 'webkitCompassHeading'].forEach(key => {
                        if (tempCalibrationData[key].length > 0) {
                            const sum = tempCalibrationData[key].reduce((s, v) => s + v, 0);
                            sensorZeroOffsets[key] = sum / tempCalibrationData[key].length;
                        } else {
                            sensorZeroOffsets[key] = 0; // Default if no data collected
                        }
                        logMessage(`Zero offset for ${key}: ${sensorZeroOffsets[key].toFixed(3)} (from ${tempCalibrationData[key].length} samples)`, 'info');
                        tempCalibrationData[key] = []; // Clear temp data
                    });
                    calibrationNotice.classList.add('hidden');
                    mainContent.classList.remove('hidden');
                    if (!chartUpdateLoopId) startChartUpdateLoop(); // Start chart loop post-calibration
                    logMessage('Calibration complete. Displaying zero-adjusted values.', 'info');
                }
            }
        }

        function processAndStoreChartData(eventData) {
            if (calibrationState !== 'complete') return;

            const nowLabel = new Date().toLocaleTimeString().split(" ")[0];
            
            ['alpha', 'beta', 'gamma', 'webkitCompassHeading'].forEach(key => {
                let rawValue = eventData[key];
                if (rawValue === null || typeof rawValue === 'undefined') return; // Skip if no raw value

                let adjustedValue;
                // User requested: Zero value - raw value
                if (key === 'alpha' || key === 'webkitCompassHeading') { // These are 0-360
                    adjustedValue = (sensorZeroOffsets[key] - rawValue + 360) % 360;
                } else { // beta, gamma (typically -180 to 180 or -90 to 90)
                    adjustedValue = sensorZeroOffsets[key] - rawValue;
                }
                
                chartData[key].values.push(adjustedValue);
                chartData[key].labels.push(nowLabel);

                if (chartData[key].values.length > MAX_CHART_POINTS) {
                    chartData[key].values.shift();
                    chartData[key].labels.shift();
                }
            });
        }
        
        function handleDeviceOrientation(event) {
            if (!orientationSensorActive) {
                logMessage(`First ${orientationEventListenerType || 'deviceorientation'} event received.`, 'info');
                orientationSensorActive = true;
                if (!rawDisplayUpdateLoopId) startRawDisplayUpdateLoop(); // Start raw display loop
                // Calibration starts automatically if in pending state
            }
            lastSensorEventData = event; // Always store the latest event

            if (calibrationState === 'pending' || calibrationState === 'collecting') {
                handleCalibrationLogic(event);
            } else if (calibrationState === 'complete') {
                processAndStoreChartData(event);
            }
        }

        // --- Raw Value Display Loop ---
        function updateRawValueDisplay() {
            if (!lastSensorEventData) return;
            const event = lastSensorEventData;
            let rawValueToShow = event[currentChartKey]; // Show raw value of the *type* selected for chart

            // Update label for raw value display
            const selectedOptionText = sensorSelect.options[sensorSelect.selectedIndex].text;
            liveRawValueLabelEl.textContent = selectedOptionText.replace('(Zero-Adjusted)', '').trim();

            currentRawValueEl.textContent = formatSensorValue(rawValueToShow);
        }

        function rawDisplayLoop(timestamp) {
            if (timestamp - lastRawDisplayUpdateTime >= RAW_DISPLAY_UPDATE_INTERVAL_MS) {
                updateRawValueDisplay();
                lastRawDisplayUpdateTime = timestamp;
            }
            rawDisplayUpdateLoopId = requestAnimationFrame(rawDisplayLoop);
        }
        function startRawDisplayUpdateLoop() {
            if (rawDisplayUpdateLoopId) cancelAnimationFrame(rawDisplayUpdateLoopId);
            logMessage("Starting live raw value display loop.", "debug");
            lastRawDisplayUpdateTime = performance.now();
            rawDisplayUpdateLoopId = requestAnimationFrame(rawDisplayLoop);
        }
        function stopRawDisplayUpdateLoop() {
            if (rawDisplayUpdateLoopId) cancelAnimationFrame(rawDisplayUpdateLoopId);
            rawDisplayUpdateLoopId = null;
        }

        // --- Chart Update Loop ---
        function updateOrientationChart() {
            if (!orientationChart || calibrationState !== 'complete' || !chartData[currentChartKey]) return;

            const data = chartData[currentChartKey];
            orientationChart.data.labels = data.labels;
            orientationChart.data.datasets[0].data = data.values;
            orientationChart.data.datasets[0].label = `Zero-Adjusted ${sensorSelect.options[sensorSelect.selectedIndex].text}`;
            orientationChart.update();
        }
        
        function chartLoop(timestamp) {
            if (calibrationState === 'complete' && timestamp - lastChartUpdateTime >= CHART_UPDATE_INTERVAL_MS) {
                updateOrientationChart();
                lastChartUpdateTime = timestamp;
            }
            chartUpdateLoopId = requestAnimationFrame(chartLoop);
        }
        function startChartUpdateLoop() {
            if (chartUpdateLoopId) cancelAnimationFrame(chartUpdateLoopId);
            logMessage("Starting chart update loop.", "debug");
            lastChartUpdateTime = performance.now();
            chartUpdateLoopId = requestAnimationFrame(chartLoop);
        }
        function stopChartUpdateLoop() {
            if (chartUpdateLoopId) cancelAnimationFrame(chartUpdateLoopId);
            chartUpdateLoopId = null;
        }

        // --- Event Listeners & Init ---
        sensorSelect.addEventListener('change', (e) => {
            currentChartKey = e.target.value;
            chartTitleEl.textContent = `Zero-Adjusted ${e.target.options[e.target.selectedIndex].text}`;
            logMessage(`Chart view changed to: ${currentChartKey}`, 'info');
            updateRawValueDisplay(); // Update raw display immediately to match selection
            updateOrientationChart(); // Update chart immediately with existing data for new key
        });

        function requestOrientationPermission() {
            logMessage('Attempting to request orientation sensor permission...', 'info');
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        logMessage(`Orientation permission state: ${permissionState}`, 'info');
                        if (permissionState === 'granted') {
                            orientationEventListenerType = 'deviceorientationabsolute';
                            window.addEventListener('deviceorientationabsolute', handleDeviceOrientation, true);
                            window.addEventListener('deviceorientation', (e) => {
                                if (orientationEventListenerType !== 'deviceorientationabsolute' || !orientationSensorActive) {
                                    orientationEventListenerType = 'deviceorientation';
                                }
                                handleDeviceOrientation(e);
                            }, true);
                            permissionSection.classList.add('hidden');
                        } else { /* ... error handling ... */ }
                    })
                    .catch(error => { /* ... error handling ... */ });
            } else if (typeof DeviceOrientationEvent !== 'undefined') {
                // ... (handle cases where permission API isn't needed) ...
                logMessage('DeviceOrientationEvent available (no specific permission API or already granted).', 'info');
                orientationEventListenerType = 'deviceorientationabsolute';
                window.addEventListener('deviceorientationabsolute', handleDeviceOrientation, true);
                window.addEventListener('deviceorientation', (e) => {
                    if (orientationEventListenerType !== 'deviceorientationabsolute' || !orientationSensorActive) orientationEventListenerType = 'deviceorientation';
                    handleDeviceOrientation(e);
                }, true);
                permissionSection.classList.add('hidden');
            } else {
                logMessage('DeviceOrientationEvent API not supported.', 'error');
                alert('Device Orientation API not supported.');
            }
        }

        window.addEventListener('load', () => {
            logMessage('App loaded. HTTPS: ' + (location.protocol === "https:" ? "Yes" : "No - Sensors may not work!"), 'info');
            orientationChart = createChart();
            currentChartKey = sensorSelect.value; // Set initial key
            chartTitleEl.textContent = `Zero-Adjusted ${sensorSelect.options[sensorSelect.selectedIndex].text}`;
            updateRawValueDisplay(); // Initial call to set label

            requestPermissionButton.addEventListener('click', requestOrientationPermission);

            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopRawDisplayUpdateLoop();
                    stopChartUpdateLoop();
                } else {
                    if (orientationSensorActive) { // Only restart if sensors were active
                        if(!rawDisplayUpdateLoopId) startRawDisplayUpdateLoop();
                        if(!chartUpdateLoopId && calibrationState === 'complete') startChartUpdateLoop();
                    }
                }
            });
        });
    </script>
</body>
</html>